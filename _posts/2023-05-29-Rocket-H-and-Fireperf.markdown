---
layout: post
title: "Use FirePerf to Profile Rocket Chip with Hypervisor Extension"
categories: RISC-V Virtualization FirePerf
---

# Background
## Rocket Chip and Rocket Core
Rocket Chip generator is an SoC generator developed in the Berkeley Architecture Research Group in the EECS Department at the University of California, Berkeley \cite{RocketChip}. Rocket Chip includes peripherals of the SoC as well as the in-order RISC-V CPU, which is generated by the Rocket Core Generator.

Rocket Core can be configured to support the RISC-V Hypervisor Extension. The generate Rocket Core with H-extension is the subject of study and will be simulated using FireSim, allowing us to gain insights of its run-time behaviour.

## FireSim and Fire Chip
FireSim is an open-source FPGA-accelerated full-system hardware simulation platform developed at Berkeley.
Firesim provides high-performance, deterministic, and cycle-exact modeling of the SoC, while cycle-accuratelymodeling I/O, including DRAM.
Firesim runs on Amazon EC2 F1, a public cloud FPGA platform, providing much usability. More importantly, FireSim is FPGA-accelerated and is sufficiently fast to simulate realistic software stacks, including Linux and KVM.
We use FireSim to simulate FireChip, a SoC that contains the Rocket Core, to analyze the performance of the Rocket Core.
FireChip connects the Rocket Core to FireSim-specific peripherals, allowing us to leverage the power of FPGA-accelerated simulation provided by FireSim.

FireSim also includes and orchestrates several sub-projects, such as Chipyard, FireMarshal and FirePerf.

## Chipyard
Chipyard is an open source framework for agile development of Chisel-based systems-on-chip.
It includes FireChip and the Rocket Core Generator as well as generators for other SoC components, such as coherent L2 cache. Together, they can be simulated by FireSim.

## FireMarshal
FireMarshal is a workload generation tool for RISC-V based systems that automates construction of boot binaries and file system images. \cite{FireMarshal}
Using FireMarshal, we can build a Linux kernel image with the KVM module that supports hardware-accelerated virtualization, which would be used as the base of workloads in our FireSim simulation. On top of the base workload, we include the micro-benchmark executable file and scripts to run it. This forms the workloads we run to analyse the Rocket Core.

## FirePerf
FirePerf allows for monitoring a simulated CPUâ€™s architectural and micro-architectural state over the course of execution through the use of counters. \cite{FirePerf}
These are similar to hardware performance counters provided by processor vendors, which are made use of by well-known tools like perf.
The counters are called AutoCounters.
These AutoCounters increments upon signal of interest being set, and are sampled by FireSim at fixed intervals.
They provides quantitative insights into the micro-architectural events, such as caches miss count, without affecting the behavior of the simulated system.
We use FirePerf to obtain the performance metrics of Rocket Core under different workloads.


# Step by step

## Compile `kvm.ko` and Guest Kernel Image
Remember to comment out `csr_write(henvcfg)`.

## Compile `lkvm-static`
Follow the other post.

## Setup Rocket Chip with Hypervisor Extension and AutoCounters
### Build Single Core Rocket Chip with H-Extension and AutoCounters
Put basic AutoCounters in `RockectCore.scala`, add PWC AutoCounters in `PTW.scala`.
To add a counter, first `import midas.targetutils.PerfCounter`, then look out for `ccover` and `cover` functions, which highlights interesting signals that could be counted.

See [appendix](#appendix-one-click-patches) for git patches for these files.

## Inline Assembly for Fireperf Triggers
```c
#define FIRESIM_START_TRIGGER asm volatile ("addi x0, x1, 0":::"cc")
#define FIRESIM_END_TRIGGER asm volatile ("addi x0, x2, 0":::"cc")
```
The expected compiled bytes are 00008013 and 00010013. Use `riscv64-unknown-linux-gnu-objdump -S` to check.


## Four Files Under `firesim/deploy`
- `config_build_recipes.yaml`
  ```yaml
  firesim_rocket_h_singlecore_no_nic_l2_llc4mb_ddr3_with_dcache_tlb_counter_ptx:
    DESIGN: FireSim
    TARGET_CONFIG: FireSimRocketHypervisorConfig
    PLATFORM_CONFIG: WithAutoCounter_BaseF1Config
    deploy_triplet: null
    platform_config_args:
        fpga_frequency: 90
        build_strategy: TIMING
    post_build_hook: null
    metasim_customruntimeconfig: null
    bit_builder_recipe: bit-builder-recipes/f1.yaml
  ```
- `config_hwdb.yaml`
  ```yaml
  firesim_rocket_h_singlecore_no_nic_l2_llc4mb_ddr3_with_dcache_tlb_counter_ptx:
    agfi: agfi-09046647cef0cb3d7
    deploy_triplet_override: null
    custom_runtime_config: null
  ```
- `config_runtime.yaml`
  ```yaml
  target_config:
    default_hw_config: firesim_rocket_h_singlecore_no_nic_l2_llc4mb_ddr3_with_dcache_tlb_counter_ptx
  tracing:
    enable: yes
    output_format: 0
    selector: 3
    start: ffffffff00008013
    end: ffffffff00010013
  autocounter:
    read_rate: 100
  workload:
    workload_name: linuxkvm.json
    terminate_on_completion: yes # Choose yes to automatically shutdown the f1 instances.
  ```
- `config_build.yaml`
  ```yaml
  agfi_to_build:
    - firesim_rocket_h_singlecore_no_nic_l2_llc4mb_ddr3_with_dcache_tlb_counter_ptx
  ```

# References
1. [Chipyard Rocket Chip generator micro-architectural parameters](https://chipyard.readthedocs.io/en/stable/Customization/Memory-Hierarchy.html#memory-hierarchy)
2. [Firemarshal workload configuration options](https://firemarshal.readthedocs.io/en/latest/workloadConfig.html#configuration-options)
3. [kvmtool man page](https://github.com/kvmtool/kvmtool/blob/master/Documentation/kvmtool.1)
4. [ccbench](https://github.com/ucb-bar/ccbench)
5. [FirePerf](https://doi.org/10.1145/3373376.3378455)
6. [RocketChip](http://www2.eecs.berkeley.edu/Pubs/TechRpts/2016/EECS-2016-17.html)
7. [FireMarshal](https://ieeexplore.ieee.org/document/9408192)

# Appendix 

## One Click Patches
To apply a patch, simply copy the content of the patch into a file, say `patch1.patch`, then `git apply patch1.patch`.

### Single Core Rocket Chip with Hypervisor Extension
Go to `firesim/target-design/chipyard/` and apply this patch.

```diff
diff --git a/generators/chipyard/src/main/scala/config/RocketConfigs.scala b/generators/chipyard/src/main/scala/config/RocketConfigs.scala
index b6677cb1..98b7b92a 100644
--- a/generators/chipyard/src/main/scala/config/RocketConfigs.scala
+++ b/generators/chipyard/src/main/scala/config/RocketConfigs.scala
@@ -7,6 +7,10 @@ import freechips.rocketchip.diplomacy.{AsynchronousCrossing}
 // Rocket Configs
 // --------------
 
+class RocketHypervisorConfig extends Config(
+  new freechips.rocketchip.subsystem.WithHypervisor ++
+  new RocketConfig)
+
 class RocketConfig extends Config(
   new freechips.rocketchip.subsystem.WithNBigCores(1) ++         // single rocket-core
   new chipyard.config.AbstractConfig)
diff --git a/generators/firechip/src/main/scala/TargetConfigs.scala b/generators/firechip/src/main/scala/TargetConfigs.scala
index 2ea848df..6475ba49 100644
--- a/generators/firechip/src/main/scala/TargetConfigs.scala
+++ b/generators/firechip/src/main/scala/TargetConfigs.scala
@@ -306,3 +306,9 @@ class FireSimLeanGemminiRocketMMIOOnlyConfig extends Config(
   new WithDefaultMemModel ++
   new WithFireSimConfigTweaks ++
   new chipyard.LeanGemminiRocketConfig)
+
+class FireSimRocketHypervisorConfig extends Config(
+  new WithDefaultFireSimBridges ++
+  new WithDefaultMemModel ++
+  new WithFireSimConfigTweaks ++
+  new chipyard.RocketHypervisorConfig)
```
